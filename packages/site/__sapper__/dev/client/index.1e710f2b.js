import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as ensure_array_like_dev, v as validate_slots, a as element, c as claim_element, b as children, f as detach_dev, g as set_style, h as attr_dev, j as add_location, k as insert_hydration_dev, n as noop, l as empty, m as destroy_each, o as validate_each_keys, p as space, q as claim_space, r as append_hydration_dev, u as update_keyed_each, t as text, w as claim_text, x as set_data_dev, y as add_render_callback, z as create_in_transition, A as destroy_block, B as writable, C as assign, D as now, E as loop, F as identity, G as validate_store, H as component_subscribe, I as onMount, J as src_url_equal, K as listen_dev, L as create_component, M as claim_component, N as mount_component, O as transition_in, P as transition_out, Q as destroy_component, R as group_outros, T as check_outros, U as head_selector } from './client.eea38d38.js';
import { i as is_date } from './utils.389ebbc6.js';

function typewriter(node, { speed = 50, delay }) {
	const valid =
		node.childNodes.length === 1 && node.childNodes[0].nodeType === 3;
	if (!valid) return {};

	const text = node.textContent;
	const duration = text.length * speed;

	return {
		duration,
		delay,
		tick: (t, u) => {
			const i = ~~(text.length * t);
			node.textContent = text.slice(0, i);
		}
	};
}

/* src/components/Input.svelte generated by Svelte v4.0.0 */
const file$3 = "src/components/Input.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i].text;
	child_ctx[7] = list[i].color;
	child_ctx[8] = list[i].l;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (64:4) {#each dots as color}
function create_each_block_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true, class: true });
			children(span).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "background", /*color*/ ctx[7]);
			attr_dev(span, "class", "svelte-1fustul");
			add_location(span, file$3, 64, 6, 1140);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(64:4) {#each dots as color}",
		ctx
	});

	return block;
}

// (68:2) {#if input.length}
function create_if_block$1(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like_dev(/*input*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*input, colors*/ 3) {
				each_value = ensure_array_like_dev(/*input*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(68:2) {#if input.length}",
		ctx
	});

	return block;
}

// (71:8) {#each line as { text, color, l }
function create_each_block_1(key_1, ctx) {
	let span;
	let t_value = /*text*/ ctx[6] + "";
	let t;
	let span_intro;

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "color", /*colors*/ ctx[1][/*color*/ ctx[7]]);
			add_location(span, file$3, 71, 10, 1378);
			this.first = span;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*input*/ 1 && t_value !== (t_value = /*text*/ ctx[6] + "")) set_data_dev(t, t_value);

			if (dirty & /*input*/ 1) {
				set_style(span, "color", /*colors*/ ctx[1][/*color*/ ctx[7]]);
			}
		},
		i: function intro(local) {
			if (local) {
				if (!span_intro) {
					add_render_callback(() => {
						span_intro = create_in_transition(span, typewriter, { delay: /*l*/ ctx[8] * 100, speed: 100 });
						span_intro.start();
					});
				}
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(71:8) {#each line as { text, color, l }",
		ctx
	});

	return block;
}

// (69:4) {#each input as line, i}
function create_each_block(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let each_value_1 = ensure_array_like_dev(/*line*/ ctx[3]);
	const get_key = ctx => /*text*/ ctx[6];
	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "line");
			set_style(div, "font-weight", /*i*/ ctx[5] === 0 ? 'bold' : 100);
			add_location(div, file$3, 69, 6, 1253);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*colors, input*/ 3) {
				each_value_1 = ensure_array_like_dev(/*line*/ ctx[3]);
				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1, t, get_each_context_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(69:4) {#each input as line, i}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div1;
	let div0;
	let t;
	let each_value_2 = ensure_array_like_dev(/*dots*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block = /*input*/ ctx[0].length && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "dots svelte-1fustul");
			add_location(div0, file$3, 62, 2, 1089);
			attr_dev(div1, "class", "container svelte-1fustul");
			add_location(div1, file$3, 61, 0, 1063);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			append_hydration_dev(div1, t);
			if (if_block) if_block.m(div1, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*dots*/ 4) {
				each_value_2 = ensure_array_like_dev(/*dots*/ ctx[2]);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (/*input*/ ctx[0].length) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Input', slots, []);
	let { input = [] } = $$props;

	const colors = {
		yellow: "#fdfd96",
		teal: "teal",
		blue: "cyan",
		green: "#98fb98",
		grey: "#fafafa",
		red: "#fa8072",
		orange: "darkorange"
	};

	const dots = ["#fe5f56", "#ffbd2f", "#28c93f"];
	const writable_props = ['input'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('input' in $$props) $$invalidate(0, input = $$props.input);
	};

	$$self.$capture_state = () => ({ typewriter, input, colors, dots });

	$$self.$inject_state = $$props => {
		if ('input' in $$props) $$invalidate(0, input = $$props.input);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [input, colors, dots];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { input: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$3.name
		});
	}

	get input() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/** @returns {(t: any) => any} */
function get_interpolator(a, b) {
	if (a === b || a !== a) return () => a;
	const type = typeof a;
	if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
		throw new Error('Cannot interpolate values of different type');
	}
	if (Array.isArray(a)) {
		const arr = b.map((bi, i) => {
			return get_interpolator(a[i], bi);
		});
		return (t) => arr.map((fn) => fn(t));
	}
	if (type === 'object') {
		if (!a || !b) throw new Error('Object cannot be null');
		if (is_date(a) && is_date(b)) {
			a = a.getTime();
			b = b.getTime();
			const delta = b - a;
			return (t) => new Date(a + t * delta);
		}
		const keys = Object.keys(b);
		const interpolators = {};
		keys.forEach((key) => {
			interpolators[key] = get_interpolator(a[key], b[key]);
		});
		return (t) => {
			const result = {};
			keys.forEach((key) => {
				result[key] = interpolators[key](t);
			});
			return result;
		};
	}
	if (type === 'number') {
		const delta = b - a;
		return (t) => a + t * delta;
	}
	throw new Error(`Cannot interpolate ${type} values`);
}

/**
 * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.
 *
 * https://svelte.dev/docs/svelte-motion#tweened
 * @template T
 * @param {T} [value]
 * @param {import('./private.js').TweenedOptions<T>} [defaults]
 * @returns {import('./public.js').Tweened<T>}
 */
function tweened(value, defaults = {}) {
	const store = writable(value);
	/** @type {import('../internal/private.js').Task} */
	let task;
	let target_value = value;
	/**
	 * @param {T} new_value
	 * @param {import('./private.js').TweenedOptions<T>} [opts]
	 */
	function set(new_value, opts) {
		if (value == null) {
			store.set((value = new_value));
			return Promise.resolve();
		}
		target_value = new_value;
		let previous_task = task;
		let started = false;
		let {
			delay = 0,
			duration = 400,
			easing = identity,
			interpolate = get_interpolator
		} = assign(assign({}, defaults), opts);
		if (duration === 0) {
			if (previous_task) {
				previous_task.abort();
				previous_task = null;
			}
			store.set((value = target_value));
			return Promise.resolve();
		}
		const start = now() + delay;
		let fn;
		task = loop((now) => {
			if (now < start) return true;
			if (!started) {
				fn = interpolate(value, new_value);
				if (typeof duration === 'function') duration = duration(value, new_value);
				started = true;
			}
			if (previous_task) {
				previous_task.abort();
				previous_task = null;
			}
			const elapsed = now - start;
			if (elapsed > /** @type {number} */ (duration)) {
				store.set((value = new_value));
				return false;
			}
			// @ts-ignore
			store.set((value = fn(easing(elapsed / duration))));
			return true;
		});
		return task.promise;
	}
	return {
		set,
		update: (fn, opts) => set(fn(target_value, value), opts),
		subscribe: store.subscribe
	};
}

/* src/components/Penguin.svelte generated by Svelte v4.0.0 */
const file$2 = "src/components/Penguin.svelte";

function create_fragment$2(ctx) {
	let div;
	let img;
	let img_src_value;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[8]);

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { alt: true, src: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "alt", "a penguing walking");
			if (!src_url_equal(img.src, img_src_value = "/penguin" + (/*walk*/ ctx[0] ? '' : '_static') + ".gif")) attr_dev(img, "src", img_src_value);
			add_location(img, file$2, 71, 2, 1458);
			attr_dev(div, "class", "one svelte-7moaqf");
			set_style(div, "transform", "translateX(" + /*$pos*/ ctx[2] + "px) rotateY(" + (/*flip*/ ctx[3] ? 180 : 0) + "deg)");
			add_location(div, file$2, 67, 0, 1363);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, img);

			if (!mounted) {
				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*walk*/ 1 && !src_url_equal(img.src, img_src_value = "/penguin" + (/*walk*/ ctx[0] ? '' : '_static') + ".gif")) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*$pos, flip*/ 12) {
				set_style(div, "transform", "translateX(" + /*$pos*/ ctx[2] + "px) rotateY(" + (/*flip*/ ctx[3] ? 180 : 0) + "deg)");
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let to;
	let from;
	let $pos;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Penguin', slots, []);
	let { walk = false } = $$props;
	let pos = tweened(0);
	validate_store(pos, 'pos');
	component_subscribe($$self, pos, value => $$invalidate(2, $pos = value));
	let flip;
	let walking = false;
	let innerWidth;
	const make_duration = (a, b, d) => Math.abs(a - b) * d;

	function start_walk() {
		$$invalidate(5, walking = true);
		pos.set(to, { duration: make_duration($pos, from, 10) });
	}

	function stop_walk() {
		$$invalidate(5, walking = false);
		pos.set($pos, { duration: 0 });
	}

	function correct_walk() {
		if (!walking) return;

		const duration = flip
		? make_duration($pos, from, 10)
		: make_duration($pos, to, 10);

		pos.set(flip ? from : to, { duration });
	}

	const writable_props = ['walk'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Penguin> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		$$invalidate(1, innerWidth = window.innerWidth);
	}

	$$self.$$set = $$props => {
		if ('walk' in $$props) $$invalidate(0, walk = $$props.walk);
	};

	$$self.$capture_state = () => ({
		tweened,
		onMount,
		walk,
		pos,
		flip,
		walking,
		innerWidth,
		make_duration,
		start_walk,
		stop_walk,
		correct_walk,
		to,
		from,
		$pos
	});

	$$self.$inject_state = $$props => {
		if ('walk' in $$props) $$invalidate(0, walk = $$props.walk);
		if ('pos' in $$props) $$invalidate(4, pos = $$props.pos);
		if ('flip' in $$props) $$invalidate(3, flip = $$props.flip);
		if ('walking' in $$props) $$invalidate(5, walking = $$props.walking);
		if ('innerWidth' in $$props) $$invalidate(1, innerWidth = $$props.innerWidth);
		if ('to' in $$props) $$invalidate(6, to = $$props.to);
		if ('from' in $$props) $$invalidate(7, from = $$props.from);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*innerWidth*/ 2) {
			$$invalidate(6, to = innerWidth > 500 ? 218 : innerWidth * 0.9 / 2 - 32);
		}

		if ($$self.$$.dirty & /*innerWidth*/ 2) {
			$$invalidate(7, from = innerWidth > 500
			? -218
			: (innerWidth * 0.9 / 2 - 32) * -1);
		}

		if ($$self.$$.dirty & /*innerWidth*/ 2) {
			innerWidth && correct_walk();
		}

		if ($$self.$$.dirty & /*walk, walking*/ 33) {
			walk && !walking && start_walk();
		}

		if ($$self.$$.dirty & /*walk, walking*/ 33) {
			!walk && walking && stop_walk();
		}

		if ($$self.$$.dirty & /*$pos, to, from*/ 196) {
			$pos >= to && $$invalidate(3, flip = true) && pos.set(from, { duration: make_duration($pos, from, 10) });
		}

		if ($$self.$$.dirty & /*$pos, from, to*/ 196) {
			$pos <= from && !$$invalidate(3, flip = false) && pos.set(to, { duration: make_duration($pos, to, 10) });
		}
	};

	return [walk, innerWidth, $pos, flip, pos, walking, to, from, onwindowresize];
}

class Penguin extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { walk: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Penguin",
			options,
			id: create_fragment$2.name
		});
	}

	get walk() {
		throw new Error("<Penguin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set walk(value) {
		throw new Error("<Penguin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Output.svelte generated by Svelte v4.0.0 */
const file$1 = "src/components/Output.svelte";

// (46:2) {#if heading.value}
function create_if_block_2(ctx) {
	let h1;
	let t_value = /*heading*/ ctx[0].value + "";
	let t;
	let h1_intro;

	const block = {
		c: function create() {
			h1 = element("h1");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t = claim_text(h1_nodes, t_value);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-17rekr8");
			add_location(h1, file$1, 46, 4, 720);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*heading*/ 1 && t_value !== (t_value = /*heading*/ ctx[0].value + "")) set_data_dev(t, t_value);
		},
		i: function intro(local) {
			if (local) {
				if (!h1_intro) {
					add_render_callback(() => {
						h1_intro = create_in_transition(h1, typewriter, {
							delay: /*heading*/ ctx[0].l * 100,
							speed: 100
						});

						h1_intro.start();
					});
				}
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(h1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(46:2) {#if heading.value}",
		ctx
	});

	return block;
}

// (52:2) {#if paragraph.value}
function create_if_block_1(ctx) {
	let p;
	let t_value = /*paragraph*/ ctx[1].value + "";
	let t;
	let p_intro;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "svelte-17rekr8");
			add_location(p, file$1, 52, 4, 849);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*paragraph*/ 2 && t_value !== (t_value = /*paragraph*/ ctx[1].value + "")) set_data_dev(t, t_value);
		},
		i: function intro(local) {
			if (local) {
				if (!p_intro) {
					add_render_callback(() => {
						p_intro = create_in_transition(p, typewriter, {
							delay: /*paragraph*/ ctx[1].l * 100,
							speed: 100
						});

						p_intro.start();
					});
				}
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(52:2) {#if paragraph.value}",
		ctx
	});

	return block;
}

// (58:2) {#if penguin}
function create_if_block(ctx) {
	let penguin_1;
	let current;

	penguin_1 = new Penguin({
			props: { walk: /*walk*/ ctx[3] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(penguin_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(penguin_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(penguin_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const penguin_1_changes = {};
			if (dirty & /*walk*/ 8) penguin_1_changes.walk = /*walk*/ ctx[3];
			penguin_1.$set(penguin_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(penguin_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(penguin_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(penguin_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(58:2) {#if penguin}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = /*heading*/ ctx[0].value && create_if_block_2(ctx);
	let if_block1 = /*paragraph*/ ctx[1].value && create_if_block_1(ctx);
	let if_block2 = /*penguin*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "container svelte-17rekr8");
			add_location(div, file$1, 44, 0, 670);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*heading*/ ctx[0].value) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*heading*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*paragraph*/ ctx[1].value) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*paragraph*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*penguin*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*penguin*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Output', slots, []);
	let { heading } = $$props;
	let { paragraph } = $$props;
	let { penguin } = $$props;
	let { walk } = $$props;

	$$self.$$.on_mount.push(function () {
		if (heading === undefined && !('heading' in $$props || $$self.$$.bound[$$self.$$.props['heading']])) {
			console.warn("<Output> was created without expected prop 'heading'");
		}

		if (paragraph === undefined && !('paragraph' in $$props || $$self.$$.bound[$$self.$$.props['paragraph']])) {
			console.warn("<Output> was created without expected prop 'paragraph'");
		}

		if (penguin === undefined && !('penguin' in $$props || $$self.$$.bound[$$self.$$.props['penguin']])) {
			console.warn("<Output> was created without expected prop 'penguin'");
		}

		if (walk === undefined && !('walk' in $$props || $$self.$$.bound[$$self.$$.props['walk']])) {
			console.warn("<Output> was created without expected prop 'walk'");
		}
	});

	const writable_props = ['heading', 'paragraph', 'penguin', 'walk'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Output> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('heading' in $$props) $$invalidate(0, heading = $$props.heading);
		if ('paragraph' in $$props) $$invalidate(1, paragraph = $$props.paragraph);
		if ('penguin' in $$props) $$invalidate(2, penguin = $$props.penguin);
		if ('walk' in $$props) $$invalidate(3, walk = $$props.walk);
	};

	$$self.$capture_state = () => ({
		typewriter,
		Penguin,
		heading,
		paragraph,
		penguin,
		walk
	});

	$$self.$inject_state = $$props => {
		if ('heading' in $$props) $$invalidate(0, heading = $$props.heading);
		if ('paragraph' in $$props) $$invalidate(1, paragraph = $$props.paragraph);
		if ('penguin' in $$props) $$invalidate(2, penguin = $$props.penguin);
		if ('walk' in $$props) $$invalidate(3, walk = $$props.walk);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [heading, paragraph, penguin, walk];
}

class Output extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			heading: 0,
			paragraph: 1,
			penguin: 2,
			walk: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Output",
			options,
			id: create_fragment$1.name
		});
	}

	get heading() {
		throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set heading(value) {
		throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get paragraph() {
		throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set paragraph(value) {
		throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get penguin() {
		throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set penguin(value) {
		throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get walk() {
		throw new Error("<Output>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set walk(value) {
		throw new Error("<Output>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/index.svelte generated by Svelte v4.0.0 */
const file = "src/routes/index.svelte";

function create_fragment(ctx) {
	let link;
	let t0;
	let main;
	let output;
	let t1;
	let input_1;
	let current;

	output = new Output({
			props: {
				heading: /*heading*/ ctx[1],
				paragraph: /*paragraph*/ ctx[2],
				penguin: /*penguin*/ ctx[3],
				walk: /*walk*/ ctx[4]
			},
			$$inline: true
		});

	input_1 = new Input({
			props: { input: /*input*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			link = element("link");
			t0 = space();
			main = element("main");
			create_component(output.$$.fragment);
			t1 = space();
			create_component(input_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = head_selector('svelte-s40vy6', document.head);

			link = claim_element(head_nodes, "LINK", {
				rel: true,
				as: true,
				crossorigin: true,
				href: true
			});

			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			claim_component(output.$$.fragment, main_nodes);
			t1 = claim_space(main_nodes);
			claim_component(input_1.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(link, "rel", "preload");
			attr_dev(link, "as", "font");
			attr_dev(link, "crossorigin", "");
			attr_dev(link, "href", "/fonts/roboto-thin-webfont.woff2");
			add_location(link, file, 58, 2, 1511);
			document.title = "mdsvex - markdown in svelte!";
			add_location(main, file, 67, 0, 1675);
		},
		m: function mount(target, anchor) {
			append_hydration_dev(document.head, link);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, main, anchor);
			mount_component(output, main, null);
			append_hydration_dev(main, t1);
			mount_component(input_1, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const output_changes = {};
			if (dirty & /*heading*/ 2) output_changes.heading = /*heading*/ ctx[1];
			if (dirty & /*paragraph*/ 4) output_changes.paragraph = /*paragraph*/ ctx[2];
			if (dirty & /*penguin*/ 8) output_changes.penguin = /*penguin*/ ctx[3];
			if (dirty & /*walk*/ 16) output_changes.walk = /*walk*/ ctx[4];
			output.$set(output_changes);
			const input_1_changes = {};
			if (dirty & /*input*/ 1) input_1_changes.input = /*input*/ ctx[0];
			input_1.$set(input_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(output.$$.fragment, local);
			transition_in(input_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(output.$$.fragment, local);
			transition_out(input_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(main);
			}

			detach_dev(link);
			destroy_component(output);
			destroy_component(input_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const _heading = "mdsvex";
const _paragraph = "svelte in markdown";
const _penguin = false;

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Routes', slots, []);

	const _input = [
		[
			{ color: "green", text: "#", l: 0 },
			{ color: "green", text: " mdsvex", l: 1 }
		],
		[
			{
				color: "grey",
				text: "svelte in markdown ",
				l: 0
			}
		],
		[
			{ color: "teal", text: "<", l: 0 },
			{ color: "blue", text: "Penguin", l: 1 },
			{ color: "teal", text: " />", l: 8 }
		]
	];

	let input = [];
	let heading = { value: "", l: 2 };
	let paragraph = { value: "", l: 0 };
	let penguin = false;
	let walk = false;
	const wait = t => new Promise(res => setTimeout(res, t));

	onMount(async () => {
		await wait(1000);
		$$invalidate(0, input = [...input, _input[0]]);
		$$invalidate(1, heading.value = _heading, heading);
		await wait(1000);
		$$invalidate(0, input = [...input, _input[1]]);
		$$invalidate(2, paragraph.value = _paragraph, paragraph);
		await wait(2500);
		$$invalidate(0, input = [...input, _input[2]]);
		await wait(1100);
		$$invalidate(3, penguin = true);
		await wait(100);

		$$invalidate(
			0,
			input[2] = [
				input[2][0],
				input[2][1],
				{ color: "yellow", text: " walk", l: 8 },
				{ color: "red", text: "=", l: 13 },
				{ color: "teal", text: "{", l: 14 },
				{ color: "orange", text: "true", l: 20 },
				{ color: "teal", text: "}", l: 15 },
				{ color: "teal", text: " />", l: 8 }
			],
			input
		);

		await wait(3000);
		$$invalidate(4, walk = true);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount,
		Input,
		Output,
		_input,
		_heading,
		_paragraph,
		_penguin,
		input,
		heading,
		paragraph,
		penguin,
		walk,
		wait
	});

	$$self.$inject_state = $$props => {
		if ('input' in $$props) $$invalidate(0, input = $$props.input);
		if ('heading' in $$props) $$invalidate(1, heading = $$props.heading);
		if ('paragraph' in $$props) $$invalidate(2, paragraph = $$props.paragraph);
		if ('penguin' in $$props) $$invalidate(3, penguin = $$props.penguin);
		if ('walk' in $$props) $$invalidate(4, walk = $$props.walk);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [input, heading, paragraph, penguin, walk];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment.name
		});
	}
}

export { Routes as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMWU3MTBmMmIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3R5cGV3cml0ZXIuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9JbnB1dC5zdmVsdGUiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDQuMC4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvbW90aW9uL3R3ZWVuZWQuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QZW5ndWluLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL091dHB1dC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdHlwZXdyaXRlcihub2RlLCB7IHNwZWVkID0gNTAsIGRlbGF5IH0pIHtcblx0Y29uc3QgdmFsaWQgPVxuXHRcdG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAzO1xuXHRpZiAoIXZhbGlkKSByZXR1cm4ge307XG5cblx0Y29uc3QgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdGNvbnN0IGR1cmF0aW9uID0gdGV4dC5sZW5ndGggKiBzcGVlZDtcblxuXHRyZXR1cm4ge1xuXHRcdGR1cmF0aW9uLFxuXHRcdGRlbGF5LFxuXHRcdHRpY2s6ICh0LCB1KSA9PiB7XG5cdFx0XHRjb25zdCBpID0gfn4odGV4dC5sZW5ndGggKiB0KTtcblx0XHRcdG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuXHRcdH1cblx0fTtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHR5cGV3cml0ZXIgfSBmcm9tIFwiLi90eXBld3JpdGVyLmpzXCI7XG5cbiAgZXhwb3J0IGxldCBpbnB1dCA9IFtdO1xuXG4gIGNvbnN0IGNvbG9ycyA9IHtcbiAgICB5ZWxsb3c6IFwiI2ZkZmQ5NlwiLFxuICAgIHRlYWw6IFwidGVhbFwiLFxuICAgIGJsdWU6IFwiY3lhblwiLFxuICAgIGdyZWVuOiBcIiM5OGZiOThcIixcbiAgICBncmV5OiBcIiNmYWZhZmFcIixcbiAgICByZWQ6IFwiI2ZhODA3MlwiLFxuICAgIG9yYW5nZTogXCJkYXJrb3JhbmdlXCJcbiAgfTtcblxuICBjb25zdCBkb3RzID0gW1wiI2ZlNWY1NlwiLCBcIiNmZmJkMmZcIiwgXCIjMjhjOTNmXCJdO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLmNvbnRhaW5lciB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWF4LXdpZHRoOiA1MHJlbTtcbiAgICBoZWlnaHQ6IDI1cmVtO1xuICAgIG1hcmdpbjogYXV0bztcbiAgICBiYWNrZ3JvdW5kOiAjMjIyO1xuICAgIGZvbnQtZmFtaWx5OiBcImZpcmEtc3ViXCI7XG4gICAgcGFkZGluZzogNnJlbSAxLjVyZW0gMS41cmVtIDEuNXJlbTtcbiAgICBmb250LXNpemU6IDEuOHJlbTtcbiAgICBsaW5lLWhlaWdodDogNXJlbTtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgYm94LXNoYWRvdzogMCAwIDEwcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cblxuICAuZG90cyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDEwcHg7XG4gICAgdG9wOiA1cHg7XG4gICAgd2lkdGg6IDgwcHg7XG4gICAgaGVpZ2h0OiAzMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAuZG90cyA+IHNwYW4ge1xuICAgIHdpZHRoOiAxMnB4O1xuICAgIGhlaWdodDogMTJweDtcbiAgICBiYWNrZ3JvdW5kOiAjZWVlO1xuICAgIG1hcmdpbjogMCA1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDUwMHB4KSB7XG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBtYXJnaW46IDAgNSU7XG4gICAgICB3aWR0aDogOTAlO1xuICAgIH1cbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICA8ZGl2IGNsYXNzPVwiZG90c1wiPlxuICAgIHsjZWFjaCBkb3RzIGFzIGNvbG9yfVxuICAgICAgPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kOntjb2xvcn1cIiAvPlxuICAgIHsvZWFjaH1cbiAgPC9kaXY+XG4gIHsjaWYgaW5wdXQubGVuZ3RofVxuICAgIHsjZWFjaCBpbnB1dCBhcyBsaW5lLCBpfVxuICAgICAgPGRpdiBjbGFzcz1cImxpbmVcIiBzdHlsZT1cImZvbnQtd2VpZ2h0OntpID09PSAwID8gJ2JvbGQnIDogMTAwfTtcIj5cbiAgICAgICAgeyNlYWNoIGxpbmUgYXMgeyB0ZXh0LCBjb2xvciwgbCB9ICh0ZXh0KX1cbiAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgaW46dHlwZXdyaXRlcj17eyBkZWxheTogbCAqIDEwMCwgc3BlZWQ6IDEwMCB9fVxuICAgICAgICAgICAgc3R5bGU9XCJjb2xvcjoge2NvbG9yc1tjb2xvcl19O1wiPlxuICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB7L2VhY2h9XG4gICAgICA8L2Rpdj5cbiAgICB7L2VhY2h9XG4gIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnLi4vc3RvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgYXNzaWduLCBsb29wLCBub3cgfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5pbXBvcnQgeyBsaW5lYXIgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuaW1wb3J0IHsgaXNfZGF0ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKiogQHJldHVybnMgeyh0OiBhbnkpID0+IGFueX0gKi9cbmZ1bmN0aW9uIGdldF9pbnRlcnBvbGF0b3IoYSwgYikge1xuXHRpZiAoYSA9PT0gYiB8fCBhICE9PSBhKSByZXR1cm4gKCkgPT4gYTtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuXHRpZiAodHlwZSAhPT0gdHlwZW9mIGIgfHwgQXJyYXkuaXNBcnJheShhKSAhPT0gQXJyYXkuaXNBcnJheShiKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludGVycG9sYXRlIHZhbHVlcyBvZiBkaWZmZXJlbnQgdHlwZScpO1xuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG5cdFx0Y29uc3QgYXJyID0gYi5tYXAoKGJpLCBpKSA9PiB7XG5cdFx0XHRyZXR1cm4gZ2V0X2ludGVycG9sYXRvcihhW2ldLCBiaSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuICh0KSA9PiBhcnIubWFwKChmbikgPT4gZm4odCkpO1xuXHR9XG5cdGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdGlmICghYSB8fCAhYikgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgY2Fubm90IGJlIG51bGwnKTtcblx0XHRpZiAoaXNfZGF0ZShhKSAmJiBpc19kYXRlKGIpKSB7XG5cdFx0XHRhID0gYS5nZXRUaW1lKCk7XG5cdFx0XHRiID0gYi5nZXRUaW1lKCk7XG5cdFx0XHRjb25zdCBkZWx0YSA9IGIgLSBhO1xuXHRcdFx0cmV0dXJuICh0KSA9PiBuZXcgRGF0ZShhICsgdCAqIGRlbHRhKTtcblx0XHR9XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXHRcdGNvbnN0IGludGVycG9sYXRvcnMgPSB7fTtcblx0XHRrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdFx0aW50ZXJwb2xhdG9yc1trZXldID0gZ2V0X2ludGVycG9sYXRvcihhW2tleV0sIGJba2V5XSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuICh0KSA9PiB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB7fTtcblx0XHRcdGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gaW50ZXJwb2xhdG9yc1trZXldKHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0Y29uc3QgZGVsdGEgPSBiIC0gYTtcblx0XHRyZXR1cm4gKHQpID0+IGEgKyB0ICogZGVsdGE7XG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW50ZXJwb2xhdGUgJHt0eXBlfSB2YWx1ZXNgKTtcbn1cblxuLyoqXG4gKiBBIHR3ZWVuZWQgc3RvcmUgaW4gU3ZlbHRlIGlzIGEgc3BlY2lhbCB0eXBlIG9mIHN0b3JlIHRoYXQgcHJvdmlkZXMgc21vb3RoIHRyYW5zaXRpb25zIGJldHdlZW4gc3RhdGUgdmFsdWVzIG92ZXIgdGltZS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtbW90aW9uI3R3ZWVuZWRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ud2VlbmVkT3B0aW9uczxUPn0gW2RlZmF1bHRzXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Ud2VlbmVkPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHdlZW5lZCh2YWx1ZSwgZGVmYXVsdHMgPSB7fSkge1xuXHRjb25zdCBzdG9yZSA9IHdyaXRhYmxlKHZhbHVlKTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsL3ByaXZhdGUuanMnKS5UYXNrfSAqL1xuXHRsZXQgdGFzaztcblx0bGV0IHRhcmdldF92YWx1ZSA9IHZhbHVlO1xuXHQvKipcblx0ICogQHBhcmFtIHtUfSBuZXdfdmFsdWVcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlR3ZWVuZWRPcHRpb25zPFQ+fSBbb3B0c11cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUsIG9wdHMpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IG5ld192YWx1ZSkpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdH1cblx0XHR0YXJnZXRfdmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0bGV0IHByZXZpb3VzX3Rhc2sgPSB0YXNrO1xuXHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0bGV0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gNDAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0aW50ZXJwb2xhdGUgPSBnZXRfaW50ZXJwb2xhdG9yXG5cdFx0fSA9IGFzc2lnbihhc3NpZ24oe30sIGRlZmF1bHRzKSwgb3B0cyk7XG5cdFx0aWYgKGR1cmF0aW9uID09PSAwKSB7XG5cdFx0XHRpZiAocHJldmlvdXNfdGFzaykge1xuXHRcdFx0XHRwcmV2aW91c190YXNrLmFib3J0KCk7XG5cdFx0XHRcdHByZXZpb3VzX3Rhc2sgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IHRhcmdldF92YWx1ZSkpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdH1cblx0XHRjb25zdCBzdGFydCA9IG5vdygpICsgZGVsYXk7XG5cdFx0bGV0IGZuO1xuXHRcdHRhc2sgPSBsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChub3cgPCBzdGFydCkgcmV0dXJuIHRydWU7XG5cdFx0XHRpZiAoIXN0YXJ0ZWQpIHtcblx0XHRcdFx0Zm4gPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgbmV3X3ZhbHVlKTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykgZHVyYXRpb24gPSBkdXJhdGlvbih2YWx1ZSwgbmV3X3ZhbHVlKTtcblx0XHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldmlvdXNfdGFzaykge1xuXHRcdFx0XHRwcmV2aW91c190YXNrLmFib3J0KCk7XG5cdFx0XHRcdHByZXZpb3VzX3Rhc2sgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgZWxhcHNlZCA9IG5vdyAtIHN0YXJ0O1xuXHRcdFx0aWYgKGVsYXBzZWQgPiAvKiogQHR5cGUge251bWJlcn0gKi8gKGR1cmF0aW9uKSkge1xuXHRcdFx0XHRzdG9yZS5zZXQoKHZhbHVlID0gbmV3X3ZhbHVlKSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHN0b3JlLnNldCgodmFsdWUgPSBmbihlYXNpbmcoZWxhcHNlZCAvIGR1cmF0aW9uKSkpKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0YXNrLnByb21pc2U7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRzZXQsXG5cdFx0dXBkYXRlOiAoZm4sIG9wdHMpID0+IHNldChmbih0YXJnZXRfdmFsdWUsIHZhbHVlKSwgb3B0cyksXG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmVcblx0fTtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHR3ZWVuZWQgfSBmcm9tIFwic3ZlbHRlL21vdGlvblwiO1xuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIGV4cG9ydCBsZXQgd2FsayA9IGZhbHNlO1xuXG4gIGxldCBwb3MgPSB0d2VlbmVkKDApO1xuICBsZXQgZmxpcDtcbiAgbGV0IHdhbGtpbmcgPSBmYWxzZTtcbiAgbGV0IGlubmVyV2lkdGg7XG5cbiAgY29uc3QgbWFrZV9kdXJhdGlvbiA9IChhLCBiLCBkKSA9PiBNYXRoLmFicyhhIC0gYikgKiBkO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0X3dhbGsoKSB7XG4gICAgd2Fsa2luZyA9IHRydWU7XG4gICAgcG9zLnNldCh0bywgeyBkdXJhdGlvbjogbWFrZV9kdXJhdGlvbigkcG9zLCBmcm9tLCAxMCkgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wX3dhbGsoKSB7XG4gICAgd2Fsa2luZyA9IGZhbHNlO1xuICAgIHBvcy5zZXQoJHBvcywgeyBkdXJhdGlvbjogMCB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcnJlY3Rfd2FsaygpIHtcbiAgICBpZiAoIXdhbGtpbmcpIHJldHVybjtcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gZmxpcFxuICAgICAgPyBtYWtlX2R1cmF0aW9uKCRwb3MsIGZyb20sIDEwKVxuICAgICAgOiBtYWtlX2R1cmF0aW9uKCRwb3MsIHRvLCAxMCk7XG5cbiAgICBwb3Muc2V0KGZsaXAgPyBmcm9tIDogdG8sIHsgZHVyYXRpb24gfSk7XG4gIH1cblxuICAkOiB0byA9IGlubmVyV2lkdGggPiA1MDAgPyAyMTggOiAoaW5uZXJXaWR0aCAqIDAuOSkgLyAyIC0gMzI7XG4gICQ6IGZyb20gPSBpbm5lcldpZHRoID4gNTAwID8gLTIxOCA6ICgoaW5uZXJXaWR0aCAqIDAuOSkgLyAyIC0gMzIpICogLTE7XG5cbiAgJDogaW5uZXJXaWR0aCAmJiBjb3JyZWN0X3dhbGsoKTtcblxuICAkOiB3YWxrICYmICF3YWxraW5nICYmIHN0YXJ0X3dhbGsoKTtcbiAgJDogIXdhbGsgJiYgd2Fsa2luZyAmJiBzdG9wX3dhbGsoKTtcblxuICAkOiAkcG9zID49IHRvICYmXG4gICAgKGZsaXAgPSB0cnVlKSAmJlxuICAgIHBvcy5zZXQoZnJvbSwgeyBkdXJhdGlvbjogbWFrZV9kdXJhdGlvbigkcG9zLCBmcm9tLCAxMCkgfSk7XG5cbiAgJDogJHBvcyA8PSBmcm9tICYmXG4gICAgIShmbGlwID0gZmFsc2UpICYmXG4gICAgcG9zLnNldCh0bywgeyBkdXJhdGlvbjogbWFrZV9kdXJhdGlvbigkcG9zLCB0bywgMTApIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLm9uZSB7XG4gICAgbWFyZ2luLXRvcDogODBweDtcbiAgICB3aWR0aDogNjRweDtcbiAgICBoZWlnaHQ6IDcwcHg7XG4gICAgbWFyZ2luOiA4OHB4IGF1dG8gMCBhdXRvO1xuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDkzMHB4KSB7XG4gICAgLm9uZSB7XG4gICAgICBtYXJnaW4tdG9wOiA2M3B4O1xuICAgIH1cbiAgfVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTp3aW5kb3cgYmluZDppbm5lcldpZHRoIC8+XG5cbjxkaXZcbiAgY2xhc3M9XCJvbmVcIlxuICBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlWCh7JHBvc31weCkgcm90YXRlWSh7ZmxpcCA/IDE4MCA6IDB9ZGVnKTtcIj5cblxuICA8aW1nIGFsdD1cImEgcGVuZ3Vpbmcgd2Fsa2luZ1wiIHNyYz1cIi9wZW5ndWlue3dhbGsgPyAnJyA6ICdfc3RhdGljJ30uZ2lmXCIgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgdHlwZXdyaXRlciB9IGZyb20gXCIuL3R5cGV3cml0ZXIuanNcIjtcblxuICBpbXBvcnQgUGVuZ3VpbiBmcm9tIFwiLi9QZW5ndWluLnN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IGhlYWRpbmc7XG4gIGV4cG9ydCBsZXQgcGFyYWdyYXBoO1xuICBleHBvcnQgbGV0IHBlbmd1aW47XG4gIGV4cG9ydCBsZXQgd2Fsaztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5jb250YWluZXIge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcbiAgICBoZWlnaHQ6IDMwcmVtO1xuICAgIG1hcmdpbi10b3A6IDEwcmVtO1xuICB9XG5cbiAgaDEge1xuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XG4gICAgZm9udC1zaXplOiA4cmVtO1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgbWFyZ2luOiAwO1xuICAgIGZvbnQtZmFtaWx5OiBcInJvYm90by1zdWJcIjtcbiAgICBjb2xvcjogIzMzMztcbiAgfVxuXG4gIHAge1xuICAgIG1hcmdpbjogMXJlbSAwO1xuICAgIGZvbnQtc2l6ZTogMi41cmVtO1xuICAgIGZvbnQtZmFtaWx5OiBcImNhdC1zdWJcIjtcbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA5MzBweCkge1xuICAgIC5jb250YWluZXIge1xuICAgICAgaGVpZ2h0OiAyNXJlbTtcbiAgICB9XG5cbiAgICBoMSB7XG4gICAgICBmb250LXNpemU6IDZyZW07XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gIHsjaWYgaGVhZGluZy52YWx1ZX1cbiAgICA8aDEgaW46dHlwZXdyaXRlcj17eyBkZWxheTogaGVhZGluZy5sICogMTAwLCBzcGVlZDogMTAwIH19PlxuICAgICAge2hlYWRpbmcudmFsdWV9XG4gICAgPC9oMT5cbiAgey9pZn1cblxuICB7I2lmIHBhcmFncmFwaC52YWx1ZX1cbiAgICA8cCBpbjp0eXBld3JpdGVyPXt7IGRlbGF5OiBwYXJhZ3JhcGgubCAqIDEwMCwgc3BlZWQ6IDEwMCB9fT5cbiAgICAgIHtwYXJhZ3JhcGgudmFsdWV9XG4gICAgPC9wPlxuICB7L2lmfVxuXG4gIHsjaWYgcGVuZ3Vpbn1cbiAgICA8UGVuZ3VpbiB7d2Fsa30gLz5cbiAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IElucHV0IGZyb20gXCIuLi9jb21wb25lbnRzL0lucHV0LnN2ZWx0ZVwiO1xuICBpbXBvcnQgT3V0cHV0IGZyb20gXCIuLi9jb21wb25lbnRzL091dHB1dC5zdmVsdGVcIjtcblxuICBjb25zdCBfaW5wdXQgPSBbXG4gICAgW1xuICAgICAgeyBjb2xvcjogXCJncmVlblwiLCB0ZXh0OiBcIiNcIiwgbDogMCB9LFxuICAgICAgeyBjb2xvcjogXCJncmVlblwiLCB0ZXh0OiBcIiBtZHN2ZXhcIiwgbDogMSB9LFxuICAgIF0sXG4gICAgW3sgY29sb3I6IFwiZ3JleVwiLCB0ZXh0OiBcInN2ZWx0ZSBpbiBtYXJrZG93biBcIiwgbDogMCB9XSxcbiAgICBbXG4gICAgICB7IGNvbG9yOiBcInRlYWxcIiwgdGV4dDogXCI8XCIsIGw6IDAgfSxcbiAgICAgIHsgY29sb3I6IFwiYmx1ZVwiLCB0ZXh0OiBcIlBlbmd1aW5cIiwgbDogMSB9LFxuICAgICAgeyBjb2xvcjogXCJ0ZWFsXCIsIHRleHQ6IFwiIC8+XCIsIGw6IDggfSxcbiAgICBdLFxuICBdO1xuXG4gIGNvbnN0IF9oZWFkaW5nID0gXCJtZHN2ZXhcIjtcbiAgY29uc3QgX3BhcmFncmFwaCA9IFwic3ZlbHRlIGluIG1hcmtkb3duXCI7XG4gIGNvbnN0IF9wZW5ndWluID0gZmFsc2U7XG5cbiAgbGV0IGlucHV0ID0gW107XG4gIGxldCBoZWFkaW5nID0geyB2YWx1ZTogXCJcIiwgbDogMiB9O1xuICBsZXQgcGFyYWdyYXBoID0geyB2YWx1ZTogXCJcIiwgbDogMCB9O1xuICBsZXQgcGVuZ3VpbiA9IGZhbHNlO1xuICBsZXQgd2FsayA9IGZhbHNlO1xuXG4gIGNvbnN0IHdhaXQgPSAodCkgPT4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIHQpKTtcblxuICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgIGlucHV0ID0gWy4uLmlucHV0LCBfaW5wdXRbMF1dO1xuICAgIGhlYWRpbmcudmFsdWUgPSBfaGVhZGluZztcbiAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgIGlucHV0ID0gWy4uLmlucHV0LCBfaW5wdXRbMV1dO1xuICAgIHBhcmFncmFwaC52YWx1ZSA9IF9wYXJhZ3JhcGg7XG4gICAgYXdhaXQgd2FpdCgyNTAwKTtcbiAgICBpbnB1dCA9IFsuLi5pbnB1dCwgX2lucHV0WzJdXTtcbiAgICBhd2FpdCB3YWl0KDExMDApO1xuICAgIHBlbmd1aW4gPSB0cnVlO1xuICAgIGF3YWl0IHdhaXQoMTAwKTtcbiAgICBpbnB1dFsyXSA9IFtcbiAgICAgIGlucHV0WzJdWzBdLFxuICAgICAgaW5wdXRbMl1bMV0sXG4gICAgICB7IGNvbG9yOiBcInllbGxvd1wiLCB0ZXh0OiBcIiB3YWxrXCIsIGw6IDggfSxcbiAgICAgIHsgY29sb3I6IFwicmVkXCIsIHRleHQ6IFwiPVwiLCBsOiAxMyB9LFxuICAgICAgeyBjb2xvcjogXCJ0ZWFsXCIsIHRleHQ6IFwie1wiLCBsOiAxNCB9LFxuICAgICAgeyBjb2xvcjogXCJvcmFuZ2VcIiwgdGV4dDogXCJ0cnVlXCIsIGw6IDIwIH0sXG4gICAgICB7IGNvbG9yOiBcInRlYWxcIiwgdGV4dDogXCJ9XCIsIGw6IDE1IH0sXG4gICAgICB7IGNvbG9yOiBcInRlYWxcIiwgdGV4dDogXCIgLz5cIiwgbDogOCB9LFxuICAgIF07XG4gICAgYXdhaXQgd2FpdCgzMDAwKTtcbiAgICB3YWxrID0gdHJ1ZTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuICA8bGlua1xuICAgIHJlbD1cInByZWxvYWRcIlxuICAgIGFzPVwiZm9udFwiXG4gICAgY3Jvc3NvcmlnaW5cbiAgICBocmVmPVwiL2ZvbnRzL3JvYm90by10aGluLXdlYmZvbnQud29mZjJcIiAvPlxuICA8dGl0bGU+bWRzdmV4IC0gbWFya2Rvd24gaW4gc3ZlbHRlITwvdGl0bGU+XG5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxtYWluPlxuICA8T3V0cHV0IHtoZWFkaW5nfSB7cGFyYWdyYXBofSB7cGVuZ3Vpbn0ge3dhbGt9IC8+XG4gIDxJbnB1dCB7aW5wdXR9IC8+XG48L21haW4+XG4iXSwibmFtZXMiOlsibGluZWFyIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEdBQUcsRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFFO0FBQ3hELENBQUMsTUFBTSxLQUFLO0FBQ1osRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDO0FBQ3BFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUs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
